/*
 * File: app/view/charts/PlayerVsPlayerViewController.js
 *
 * This file was generated by Sencha Architect
 * http://www.sencha.com/products/architect/
 *
 * This file requires use of the Ext JS 6.5.x Modern library, under independent license.
 * License of Sencha Architect does not include license for Ext JS 6.5.x Modern. For more
 * details see http://www.sencha.com/license or contact license@sencha.com.
 *
 * This file will be auto-generated each and everytime you save your project.
 *
 * Do NOT hand edit this file.
 */

Ext.define('Enif.view.charts.PlayerVsPlayerViewController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.charts.playervsplayer',

    filterMatchesStore: function(player1id, player2id) {
        const VM = this.getViewModel();


        const playerId = player1id ? player1id :  VM.get('firstPlayerId');
        const playerId2 = player2id ? player2id : VM.get('secondPlayerId');


        let gridStore = VM.getStore('playedGames');

        // clear any filtering on the Store
        gridStore.clearFilter();

        gridStore.filterBy(function(rec) {

            let playerWhite = rec.get('playerWhite'),
                playerBlack = rec.get('playerBlack');

            if(playerWhite === playerId && playerBlack === playerId2 || playerBlack === playerId && playerWhite ===  playerId2) {
                return true;
            } else {
                return false;
            }
        });
        //<debug>
        console.log('The filter has been applied on the store');
        //</debug>
    },

    tooltipRenderer: function(toolTip, record, ctx) {

        const score = Math.round(record.get(ctx.field)),
              match = record.get('match'),
              pbId = match.get('playerBlack'),
              pWId = match.get('playerWhite'),
              pb = Enif.app.getController('storeLoadController').getPlayerName(pbId),
              pw = Enif.app.getController('storeLoadController').getPlayerName(pWId),
              result = match.get('result'),
              time = Ext.Date.format(new Date(match.get('timestamp')), 'd.M.y');

        let resultName = '';
        if (result == 'black') {
            resultName = pb;
        } else if(result == 'white'){
            resultName = pw;
        } else {
           resultName = result;
        }


        const html = `<b>Black: ${pb}</b> vs <b>White: ${pw}</b><br><b>Winner: ${resultName}</b><br>Played: ${time}`;
        toolTip.setTitle(`<b>Score: ${score}</b>`);
        toolTip.setHtml(html);

    },

    onLoadButtonTap: function(button, e, eOpts) {
        const topPlayerSelection = this.lookupReference('firstPlayerCombo').getSelection(),
        bottomPlayerSelection = this.lookupReference('secondPlayerCombo').getSelection(),
        animate = this.lookupReference('animateCheckbox').getChecked(),
        animateDelay = this.lookupReference('delayMs').getValue();

        const topPlayer = topPlayerSelection ? topPlayerSelection.get('name') : "";
        const bottomPlayer = bottomPlayerSelection ? bottomPlayerSelection.get('name') : "";


        if (topPlayer == bottomPlayer && (topPlayer !== "" && topPlayer !== null)){
            Ext.toast('Player can\'t play againts himself', 3000);
            // <debug>
            console.log(`Players playing against each other:${topPlayer} vs ${bottomPlayer}`);
            // </debug>

            return; // end the execution
        }

        const VM = this.getViewModel();

        VM.set('firstPlayerId', topPlayerSelection.get('uid'));
        VM.set('secondPlayerId', bottomPlayerSelection.get('uid'));

        VM.set('animate', animate);
        VM.set('animateDelay', animateDelay);


        VM.getStore('playedGamesScore').load();

    },

    onGridPanelExpand: function(panel, eOpts) {
        // <debug>
        console.log('Grid Panel has been shown');
        // </debug>
        // we need to refresh the grid
        this.lookupReference('gridWithMatches').refresh();
    },

    onGridPanelDrawershow: function(panel, eOpts) {
        // this event is triggered when you just show drawer
        this.onGridPanelExpand();
    },

    onStoreLoad: function(store, records, successful, operation, eOpts) {
        const playerData = Ext.getStore('SortedPlayerData').getData();
        if (!playerData) return;

        let thisStoreData = [];

        const VM = this.getViewModel(),
        playerId = VM.get('firstPlayerId'),
        playerId2 = VM.get('secondPlayerId'),
        animate = VM.get('animate'),
        animateDelay = VM.get('animateDelay');

        //init filtering of the grid store
        this.filterMatchesStore();

        const gameStore = VM.getStore('playedGames');

        let score = 0,
        wins = 0,
        loses = 0,
        draws = 0;

        // create first record to start at 0
        thisStoreData.push({
            data: 0,
            time: 0,
            zeroData: 0
        });

        if (animate) {
            store.setData(thisStoreData);
        }

        // reverse the items so the first match is calculated first
        const matches = gameStore.getData().items.reverse();
        let pushCounter = 0;

        for(let i = 0; i < matches.length; i++){
            const rec = matches[i];

            const saveData = () => { //jshint ignore:line
                pushCounter++;

                thisStoreData.push({
                    data: score,
                    time: rec.get('timestamp'),
                    zeroData: 0,
                    match: rec
                });


                if(animate){
                    const dataToPush = thisStoreData;
                    //<debug>
                    //console.log('Gonna push the recrods, but first lets wait', animateDelay * pushCounter);
                    //console.log('Records:', dataToPush);
                    //</debug>

                    setTimeout((recordsToShow, wins, loses, draws, score) => {

                        VM.set('numberOfMatches', wins + loses + draws);
                        VM.set('wins', wins);
                        VM.set('loses', loses);
                        VM.set('draws', draws);
                        VM.set('score', score);

                        store.setData(recordsToShow);
                    }, animateDelay * pushCounter, dataToPush.slice(), wins, loses, draws, score);
                    // don't forget that arrays are passed as reference in JS
                }

            };


            if ((rec.get('playerWhite') === playerId &&
            rec.get('playerBlack') === playerId2 &&
            rec.get('result') === 'white') ||
            (rec.get('playerBlack') === playerId &&
            rec.get('playerWhite') === playerId2 &&
            rec.get('result') === 'black')) {
                wins ++;
                score++;

                saveData();


            } else if((rec.get('playerWhite') === playerId &&
            rec.get('playerBlack') === playerId2 &&
            rec.get('result') === 'black') ||
            (rec.get('playerBlack') === playerId &&
            rec.get('playerWhite') === playerId2 &&
            rec.get('result') === 'white')) {
                score--;
                loses++;

                saveData();

            } else if((rec.get('playerWhite') === playerId &&
            rec.get('playerBlack') === playerId2 &&
            rec.get('result') === 'draw') ||
            (rec.get('playerBlack') === playerId &&
            rec.get('playerWhite') === playerId2 &&
            rec.get('result') === 'draw')) {

                draws++;
                saveData();
            }

        }

        if(!animate){
            store.setData(thisStoreData);

            VM.set('numberOfMatches', wins + loses + draws);
            VM.set('wins', wins);
            VM.set('loses', loses);
            VM.set('draws', draws);
            VM.set('score', score);
        }

    }

});